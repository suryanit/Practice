import java.util.*;

interface EvictionStrategy {
    String get(String key);
    void put(String key, String value);
    void delete(String key);
}

class LRUEvictionStrategy implements EvictionStrategy {
    
    private class ListNode {
        String key;
        String val;
        ListNode next;
        ListNode prev;

        ListNode(String key, String val) {
            this.key = key;
            this.val = val;
        }
    }

    private final int capacity;
    private final Map<String, ListNode> cache;
    private final ListNode head;
    private final ListNode tail;

    public LRUEvictionStrategy(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
      
        this.head = new ListNode("", "");
        this.tail = new ListNode("", "");
        head.next = tail;
        tail.prev = head;
    }

    @Override
    public String get(String key) {
        if (!cache.containsKey(key)) {
            return null;
        }
        ListNode node = cache.get(key);
        moveToTail(node); 
        return node.val;
    }

    @Override
    public void put(String key, String value) {
        if (cache.containsKey(key)) {
            ListNode node = cache.get(key);
            node.val = value;
            moveToTail(node);
        } else {
            if (cache.size() >= capacity) {
                ListNode lru = head.next;
                removeNode(lru);
                cache.remove(lru.key);
            }
            ListNode newNode = new ListNode(key, value);
            cache.put(key, newNode);
            addToTail(newNode);
        }
    }

    @Override
    public void delete(String key) {
        if (cache.containsKey(key)) {
            ListNode node = cache.remove(key);
            removeNode(node);
        }
    }

    private void moveToTail(ListNode node) {
        removeNode(node);
        addToTail(node);
    }

    private void addToTail(ListNode node) {
        node.prev = tail.prev;
        node.next = tail;
        tail.prev.next = node;
        tail.prev = node;
    }

    private void removeNode(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

class CacheBuilder {
    private final EvictionStrategy strategy;

    public CacheBuilder(int capacity, String strategyType) {
        if ("LRU".equalsIgnoreCase(strategyType)) {
            this.strategy = new LRUEvictionStrategy(capacity);
        } else {
            throw new IllegalArgumentException("Unsupported strategy type: " + strategyType);
        }
    }

    public String get(String key) {
        return strategy.get(key);
    }

    public void put(String key, String value) {
        strategy.put(key, value);
    }

    public void delete(String key) {
        strategy.delete(key);
    }
}

public class Main {
    public static void main(String[] args) {

        CacheBuilder myCache = new CacheBuilder(2, "LRU");

        myCache.put("k1", "v1");
        myCache.put("k2", "v2");
        
        // Moves k1 to the tail (MRU)
        System.out.println("Value for k1: " + myCache.get("k1")); 

        // Cache full: evicts k2 because k1 was recently accessed
        myCache.put("k3", "v3"); 

        System.out.println("Value for k2 (evicted): " + myCache.get("k2")); // null
        System.out.println("Value for k3: " + myCache.get("k3")); // v3
    }
}
